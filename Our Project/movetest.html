
			<!DOCTYPE html>
            <html lang="en">
                <head>
                    <title>three.js webgl - transform controls</title>
                    <meta charset="utf-8">
                    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
                    <link type="text/css" rel="stylesheet" href="main.css">
                </head>
                <body>
            
                    <div id="info">
                        "Space" translate | "R" rotate | "C" toggle camera 
            
                 
    <script src="libraries\three.js"></script>
    <script src="libraries\three.min.js"></script>  
    <script src="libraries\OrbitControls.js"></script>
  <script src="libraries\TransformControls.js"></script>
  <script src="libraries\PerspectiveCamera.js"></script>
  <script src="libraries\OrthographicCamera.js"></script>

  
  <script type="module">

var cameraPersp, cameraOrtho, currentCamera;
			var scene, renderer, control, orbit;

			init();
			render();

			function init() {

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				const aspect = window.innerWidth / window.innerHeight;

				cameraPersp = new THREE.PerspectiveCamera( 50, aspect, 0.01, 30000 );
				cameraOrtho = new THREE.OrthographicCamera( - 600 * aspect, 600 * aspect, 600, - 600, 0.01, 30000 );
				currentCamera = cameraPersp;

				currentCamera.position.set( 1000, 500, 1000 );
				currentCamera.lookAt( 0, 200, 0 );

				scene = new THREE.Scene();
				
				var light = new THREE.DirectionalLight( 0xffffff, 2 );
				light.position.set( 1, 1, 1 );
				scene.add( light );

				var geometry = new THREE.BoxBufferGeometry( 200, 200, 200 );
				var material = new THREE.MeshLambertMaterial( { map: texture, transparent: true } );

				orbit = new OrbitControls( currentCamera, renderer.domElement );
				orbit.update();
				orbit.addEventListener( 'change', render );

				control = new TransformControls( currentCamera, renderer.domElement );
				control.addEventListener( 'change', render );

				control.addEventListener( 'dragging-changed', function ( event ) {

					orbit.enabled = ! event.value;

				} );

				var mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				control.attach( mesh );
				scene.add( control );

				window.addEventListener( 'resize', onWindowResize, false );

				window.addEventListener( 'keydown', function ( event ) {

					switch ( event.keyCode ) {

 
case 32: // Space key to transform (activate x and z transforms)
control.showX = control.showX;
control.showZ = control.showZ;
control.setMode( "translate" );
break;

case 82: // R to rotate object (activate Y rotation)
control.showX = ! control.showX;
control.showY = control.showY;
control.showZ = ! control.showZ;
control.setMode( "rotate" );
break;

case 67: // C
const position = currentCamera.position.clone();
currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
currentCamera.position.copy( position );
orbit.object = currentCamera;
control.camera = currentCamera;
currentCamera.lookAt( orbit.target.x, orbit.target.y, orbit.target.z );
onWindowResize();
break;
} 
                });



			function onWindowResize() {

				const aspect = window.innerWidth / window.innerHeight;

				cameraPersp.aspect = aspect;
				cameraPersp.updateProjectionMatrix();

				cameraOrtho.left = cameraOrtho.bottom * aspect;
				cameraOrtho.right = cameraOrtho.top * aspect;
				cameraOrtho.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function render() {

                renderer.render( scene, currentCamera ); 
            }
        };
            </script>

            </body>
        </html>